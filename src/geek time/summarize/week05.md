# 算法训练营期中总结

大家好，我是DD3的李正龙，很荣幸能给大家总结一下近期我学习的内容，希望能帮助到大家共同学习，共同进步。

近期我在极客上学习[算法训练营](https://u.geekbang.org/subject/algorithm/1000343?utm_source=time_web&utm_medium=menu&utm_term=timewebmenu)的相关课程。目前课程刚刚过半，正好可以将之前所学习到的东西总结一下，也是一种温故知新。

这次总结的内容也都是我自己的所思所想所感，由于自己刚开始学习水平有限，如果总结中有什么不对的地方希望大家能帮我指出，共同进步，感谢大家。

## 前言

我觉得程序员的技能天赋树主要有两个子树：`外功招式`和`内功心法`。

在“码农”这片腥风血雨的江湖中，能力是我们赖以生存的唯一途径，如果不想被奔涌而来的后浪所淘汰，就要不断修炼自己，点满更深的天赋点，学会更多的武功招式。而修炼的前提，是需要先找到自己的门派，学习门派中的各个招式，待到学成之后就可以行走江湖了。其中的门派，其实就是我们日常工作中所用到的技术栈，所有的招式，其实就是这种技术栈下所用到的各种技术框架和编程思想。我觉得以上这些可以统一称为程序员的外功招式。

但是，如果想在江湖中走得更远，那最重要的其实是我们的内功心法即算法。想虚竹子获得了无崖子70年的内功之后，可以平地飞天，松子杀人是多么的潇洒飘逸，但是我们没有主角光环，没法直升70级，那只能靠我们自己不断修炼最终成为主角了。

## 第一招：入门式

最近有个微博上很火的段子，不知道大家看过没有：

![isEven](https://github.com/lzl82891314/AlgorithmDeliberatePractice/blob/master/src/geek%20time/summarize/resource/isEven.png)

虽然这只是个段子（我不知道是不是在黑C#程序员（笑）），但是已经可以看出算法的重要性了，这个题大家肯定都可以当God，这种利用计算机`快速稳定`解决重复问题的方法我觉得就可以被定义为一种算法了。而这里又引出了两个概念：快速和稳定。

快速其实就是指程序的`时间复杂度`，与其对应的概念就是`空间复杂度`。在如今这个内存已经普遍充裕的时代，一个算法的好坏的唯一度量标准可能就是时间复杂度了。这两个概念统一都用大O表示法表示，其主要可以分为O(1)、O(logn)、O(n)、O(nlogn)、O(n^2)、O(2^n)。这些都是数据结构的基础概念了，想必大家的理解比我更深，我就不在这班门弄斧了。但是得说一个重要的概念就是：

> 程序算法的优劣其实就是时间和空间的博弈

目前一个设计无误的算法基本都是利用基础数据结构进行空间换时间的，因为目前不存在一种数据结构即快速又占用率低，因为如果那样就不会存在其他基础的数据结构了。

接着上面的那个图，有人在评论里给出了一种解决方式，我在这写出来让大家观赏一下：

``` C#
private IsEven(int number) {
    if (number == 1) return false;
    if (number == 2) return true;
    return IsEven(number - 2);
}
```

这里就引出了我们日常工作中可能用到的最多的一种算法了，递归。而说到递归就又回到那个基础的绕不开的一个经典问题：斐波那契数列问题。

相信一个普通的斐波那契数列的代码大家可以很轻松的写出来：

``` C#
private int Fibonacci(int n) {
    if (n <= 1) return 0;
    if (n == 2) return 1;
    return Fibonacci(n - 1) + Fibonacci(n - 2);
}
```

上述的斐波那契数列代码看起来其实十分整洁简练，但是大部人可能不知道这个算法的时间复杂度是`O(2^n)`是一个最慢的算法类型，因为其状态展开树为：

![Fibonacci](https://github.com/lzl82891314/AlgorithmDeliberatePractice/blob/master/src/geek%20time/summarize/resource/fibonacci.jpg)

